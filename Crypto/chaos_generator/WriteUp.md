## 考点

原根，优化剪枝，乱搞

## 工具

python

## 步骤

题目仿佛用很复杂的方法来生成$p$，$q$，其中还有什么二进制位移什么的，都是混淆视听。

注意到生成质数只看由$g^{random(114514)}$唯一确定，尝试发现$g$并不是原根，而且$ord(g)=28361$,非常小，我们只需要爆破由$g$的生成群元素即可。所以$p,q$至多有$28361*28361$种可能，但是爆破时间过长，我们可以先爆破$p$,根据$N$和`next_prime`的范围对$q$的爆破范围进行约束从而极大减少爆破范围。

`exp.py`:

```python
from libnum import invmod, n2s
from gmpy2 import next_prime

p = 74318463376311964657848870236469351222861371046000989980725143814597652972079
g = 10135979321704650132001133858909900216529170765388975908180263641843583056994
N = 46560744052031492000075598084262814175984839629218579003339825251165084535288738001196294968344403225296587992393409186512832442084313772062189640462381680977493272839744503195012137744652370256066011590369737294828406013950810998314546935103160880000499234316605414326064476117367727072344004644766745175963
c = 23334367507777982721463578689282517343702422017568936413397591619899938216343800551132594869485665306596562901129144338015710969994575939792628945297846703002122172051500112438041566171992504143239954624689779597268840813422509867439815100802585538453946245512563984478922752113443379737653491922857109660034
e = 0x10001

def chaos_maker(p, g, x):
    res = 0
    global rsf
    for i in range(256):
        x = rsf[x]
        if x < (p-1) // 2:
            res -= (1 << i) - 1
        elif x > (p-1) // 2:
            res += (1 << i) + 1
        else:
            res ^= (1 << i + 1)
        x = x % 28361
    return res if res > 0 else -res

rsf = [0] * 28361
rsf[0] = 1
for i in range(1, 28361):
    rsf[i] = (g * rsf[i-1]) % p
WOW = [0] * 28361
for i in range(0, 28361):
    WOW[i] = chaos_maker(p, g, i)
if 34921423738238217667426170081985242050986185851542392329360223748418245446709 in WOW:
    print(1)
WOW.sort()
ok = 0
for i in range(0, 28361):
    lef = i+1
    rig = 28360
    mid, best = 0, 0
    while lef <= rig:
        mid = (lef + rig) // 2
        if (WOW[i]*WOW[i] + WOW[mid] * WOW[mid]) * 2 * WOW[i] * WOW[mid] >= N:
            best = mid
            rig = mid -1
        else:
            lef = mid + 1
    if best == 0:
        continue
    for j in range(best-1, min(best+30, 28361)):
        u = WOW[i] * WOW[i] + WOW[j] * WOW[j]
        v = 2 * WOW[i] * WOW[j]
        if u * v <= N and N <= (u+1000) * (v+1000):
            u = next_prime(u)
            v = next_prime(v)
            if u * v == N:
                ok = True
                break
    if ok:
        break

# u = 13207168490744652956999406596846767472614127517045010655090178723910296606220559473477009696618646553552917605315941229263316963221556883007951846286507319
# v = 13206540315287197799978983146788490475082830408392129019383447128092673850363700139125558344894148410716241976023782262109119063597770109472702331423302981
print(u)
print(v)
phi = (u-1)*(v-1)
d = invmod(e, phi)
flag = pow(c,d,N)
print(n2s(int(flag)))
```

当然还可以乱搞，直接多跑几次这个`chaos_maker`的函数发现实际的数真不多，枚举就好了。

## 总结

密码题当然要多尝试，不尝试是不能发现这些大数之间的性质以及存在问题的。
